use amzn_must::{
    async_recv_msg,
    future::{self, asyncio::Tagged},
    recv_msg_block, send_msg, send_tagged_msg, thread, Config,
};

mod utils;
use utils::init_log;

#[derive(Clone, PartialEq, Debug)]
struct TaggedU32 {
    tag: u32,
    value: u32,
}

impl Tagged for TaggedU32 {
    fn tag(&self) -> Option<u32> {
        Some(self.tag)
    }
}

#[test]
fn nbio() {
    let stats = amzn_must::verify(Config::builder().with_verbose(1).build(), || {
        future::block_on(async {
            println!("HERE: block on");
            //let _r: u32 = recv_msg_block();
            let _r: TaggedU32 = async_recv_msg(10u32).await;
            // futures::future::pending::<()>().await;
        });
    });
    println!("Execs = {}", stats.execs);
}

#[test]
fn nbio2() {
    //init_log();
    let stats = amzn_must::verify(
        Config::builder()
            .with_policy(amzn_must::SchedulePolicy::LTR)
            .with_verbose(1)
            .build(),
        || {
            let maintid = thread::current_id();
            let _ = thread::spawn(move || {
                //send_msg(maintid, 1u32);
                send_tagged_msg(
                    maintid,
                    10u32,
                    TaggedU32 {
                        tag: 10u32,
                        value: 42u32,
                    },
                );
            });
            future::block_on(async {
                //let _r: u32 = recv_msg_block();
                //println!("HERE: {r}");
                let _r: TaggedU32 = async_recv_msg(10u32).await;
                // futures::future::pending::<()>().await;
            });
        },
    );
    println!("Execs = {}", stats.execs);
}

#[test]
fn nbio3() {
    init_log();
    let stats = amzn_must::verify(
        Config::builder()
            .with_policy(amzn_must::SchedulePolicy::LTR)
            .with_verbose(1)
            .build(),
        || {
            let t = thread::spawn(move || {
                println!("In spawned thread {:}", thread::current_id());
                future::block_on(async {
                    let r: TaggedU32 = async_recv_msg(10u32).await;
                    // futures::future::pending::<()>().await;
                    println!("r = {:?}", r);
                });
            });
            let tid = t.thread().id();
            let _ = thread::spawn(move || {
                send_tagged_msg(
                    tid,
                    10u32,
                    TaggedU32 {
                        tag: 10u32,
                        value: 24u32,
                    },
                );
            });

            send_tagged_msg(
                t.thread().id(),
                10u32,
                TaggedU32 {
                    tag: 10u32,
                    value: 42u32,
                },
            );
        },
    );
    println!("Execs = {}", stats.execs);
}

#[test]
fn nbio4() {
    let stats = amzn_must::verify(Config::builder().with_verbose(1).build(), || {
        future::block_on(async {
            let myid = thread::spawn(move || {
                future::block_on(async {
                    let r: TaggedU32 = async_recv_msg(10u32).await;
                    assert_eq!(r.value, 10);
                    //let r: TaggedU32 = async_recv_msg(11u32).await;
                    //assert_eq!(r.value, 11);
                });
            })
            .thread()
            .id();
            let _ = thread::spawn(move || {
                future::block_on(async {
                    send_tagged_msg(
                        myid,
                        10u32,
                        TaggedU32 {
                            tag: 10u32,
                            value: 10u32,
                        },
                    );
                    send_tagged_msg(
                        myid,
                        11u32,
                        TaggedU32 {
                            tag: 11u32,
                            value: 11u32,
                        },
                    );
                });
            });
        });
    });
    println!("Execs = {}", stats.execs);
    println!("Blocked = {}", stats.block);
}
